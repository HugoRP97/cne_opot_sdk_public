from scipy.interpolate import lagrange
from numpy.polynomial.polynomial import Polynomial, polyval
from random import randrange, randint
import numpy as np
import sympy
import logging
from Crypto.Util import number


##########################################
# All these implementations are referred to the lagrange scipy.interpolate - lagrange library
# At this moment is not used but probably in the future will be necessary.


def calculate_lagrange_polyn(node_numbers):
    x_elements = set([])
    y_elements = set([])
    last_term = -1
    polyn, coef = "", ""
    while last_term < 0:
        x_elements.clear()
        y_elements.clear()

        # Point (0,0) is added to avoid the creation of a independent term.
        x_elements.add(0)
        y_elements.add(0)
        # To avoid repeated numbers in the polynomial generation.
        while len(x_elements) != node_numbers:
            x_elements.add(randrange(50))
        while len(y_elements) != node_numbers:
            y_elements.add(randrange(50))
        polyn = lagrange(list(x_elements), list(y_elements))
        coef = list(Polynomial(polyn).coef)
        last_term = coef[len(coef) - 1]

    print("####################################")
    print("[POLYN]:\n{}".format(polyn))
    print("[COEF]:\n{}".format(coef))
    print("[LAST TERM]:{}".format(last_term))
    print("[POINTS]:")
    for i in range(0, node_numbers):
        print("{}[X,Y]:({},{})".format(i, list(x_elements)[i], list(y_elements)[i]))
    return {"polyn": "{}".format(polyn),
            "coef": coef,
            "x_elements": list(x_elements),
            "y_elements": list(y_elements)}


def other_lagrange_polyn(node_numbers):
    x_elements = np.array([randrange(1, 50) for _ in range(0, node_numbers)])
    y_elements = 3 * x_elements ** 7
    polyn = lagrange(list(x_elements), y_elements)
    coef = list(Polynomial(polyn).coef)
    last_term = coef[len(coef) - 1]

    print("####################################")
    print("[POLYN]:\n{}".format(polyn))
    print("[COEF]:\n{}".format(coef))
    print("[LAST TERM]:{}".format(last_term))
    print("[POINTS]:")
    for i in range(0, len(x_elements)):
        print("{}[X,Y]:({},{})".format(i, list(x_elements)[i], list(y_elements)[i]))
    print("####################################")

    return {"polyn": "{}".format(polyn),
            "coef": coef,
            "x_elements": list(x_elements),
            "y_elements": list(y_elements)}


def print_lagrange(node_lagrange_polyn):
    """
    :param node_lagrange_polyn: It represents the lagrange polyn formatted as DICTIONARY to be printed. This function is
    called on Node functionality so means that this is the lagrange on the node side.
    When the node has this information, we have all the information that we need to implement OPoT.
    :return:
    """

    print("[POLYN]:\n{}".format(node_lagrange_polyn["polyn"]))
    print("[COEF]:\n{}".format(node_lagrange_polyn["coef"]))
    print("[X_ELEMENT: {}]".format(node_lagrange_polyn["x_element"]))
    print("[Y_ELEMENT: {}]".format(node_lagrange_polyn["y_element"]))
    print("[LPC: {}]".format(node_lagrange_polyn["LPC"]))


##########################################


def generate_random_polyn(degree, prime):
    # We create a list of coefficients term that will represent a polynomial.
    # 0 is particulary added for avoid independent term generation.
    polynomial_terms = [randint(1, prime - 1) for _ in range(0, degree)]
    polynomial_terms.append(0)
    return polynomial_terms


def generate_x_points_for_polyn(small_values_condition, degree, prime):
    # Random x points are autogenerated. Depending on a condition we will create random numbers
    # between 1 and "big prime number" or [1, 100]
    return [randint(0, prime - 1) if small_values_condition else randint(1, 100)
            for _ in range(0, degree)]


def generate_y_points_for_polyn(polyn, x_points, prime):
    # Y points are calculated with polynomial and x points information calculated previously.
    # Need to be carefull due to this implementations returns an int64 bits.
    return np.polyval(np.poly1d(polyn), x_points) % prime


def handle_calculate_lpcs(x_points, prime):
    lpcs = []

    def extended_gcd(aa, bb):
        lastremainder, remainder = abs(aa), abs(bb)
        x, lastx, y, lasty = 0, 1, 1, 0

        while remainder:
            lastremainder, (quotient, remainder) = remainder, divmod(lastremainder, remainder)
            x, lastx = lastx - quotient * x, x
            y, lasty = lasty - quotient * y, y
        return lastremainder, lastx * (-1 if aa < 0 else 1), lasty * (-1 if bb < 0 else 1)

    def modinv(a, m):
        g, x, y = extended_gcd(a, m)
        if g != 1:
            raise ValueError
        return x % m

    for i in range(0, len(x_points)):
        top = 1
        bot = 1
        for j in range(0, len(x_points)):
            if i != j:
                top = top * (-x_points[j])
                bot = bot * (x_points[i] - x_points[j])
        lpc_value = (top * sympy.mod_inverse(bot, prime)) % prime
        # print("LPC" + str(i) + ": " + str((top * modinv(bot, prime)) % prime))
        lpcs.append(lpc_value)
    return lpcs


def sympy_calculate_lpcs(x_points, prime):
    lpcs = []
    for i in range(0, len(x_points)):
        top = 1
        bot = 1
        for j in range(0, len(x_points)):
            if i != j:
                top = top * (-x_points[j])
                bot = bot * (x_points[i] - x_points[j])
        lpc_value = (top * sympy.mod_inverse(bot, prime)) % prime
        # print("[LPC: {}]".format(lpc_value))
        lpcs.append(lpc_value)
    return lpcs


def generate_lagrange_parameters(number_of_nodes, test=False):
    """
    This method will return the generated lagrange_parameters for each of the nodeso
    :number_of_nodes: The number of nodes that are in the path
    :return: It will return the lagrange parameters in a dictionary.
    """
    # For testing purposes
    test_origin_polyn = test['lagrange_parameters']['test_origin_polyn'] if test else None
    test_x_points = test['lagrange_parameters']['test_x_points'] if test else None
    test_prime = test['lagrange_parameters']['test_prime'] if test else None

    # Set the polynomial degree
    polynomial_degree = number_of_nodes - 1

    founded = False
    # Store the lpc_information (the SSS parameters) to keep track of all the values in the instance of the
    # controller This is also needed, since we want to check in the case of an error, in which node the OPoT failed
    lpc_information_package = {}
    while not founded:
        try:
            # TODO: For 32 bits primes starts to be unstable due to most probably overflow problems.
            lpc_information_package = {"prime_number": test_prime if test_prime else number.getPrime(16)}
            logging.debug("Primer number generated {}".format(lpc_information_package["prime_number"]))

            lpc_information_package["polynomial"] = test_origin_polyn if test_origin_polyn \
                else generate_random_polyn(degree=polynomial_degree,
                                           prime=lpc_information_package["prime_number"])

            # For correct Lagrange polynomial calculation we need one more point than the grade of the polynomial.
            lpc_information_package["x_points"] = test_x_points if test_x_points \
                else generate_x_points_for_polyn(small_values_condition=False,
                                                 degree=polynomial_degree + 1,
                                                 prime=lpc_information_package["prime_number"])

            # This implementations returns a list of int64 bits. Need to be careful with that due to
            # json transformation step ahead.
            lpc_information_package["y_points"] = \
                generate_y_points_for_polyn(polyn=lpc_information_package["polynomial"],
                                            x_points=lpc_information_package["x_points"],
                                            prime=lpc_information_package["prime_number"])
            # Handled modular inverse implementation
            lpc_information_package["LPCs"] = handle_calculate_lpcs(x_points=lpc_information_package["x_points"],
                                                                    prime=lpc_information_package["prime_number"])
            founded = True
        except Exception as unhandled_exception:
            logging.error("Error with modular inverse trying again {}".format(unhandled_exception))
    return lpc_information_package


def calculate_new_cml(prev_cml, public_secret, **kwargs):
    """
    Method that will calculate the new cumulative value.

    :param prev_cml:
    :param public_secret:
    :param lagrange_data: it should contain the y_point, LPC and prime number
    :return: New cumulative value
    """
    return ((int(kwargs["secret_share"]) + public_secret) * int(kwargs["lpc"])) + \
           (prev_cml % int(kwargs["prime_number"]))
